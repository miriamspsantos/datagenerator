Sekwencja
1. podział na część uczącą i testującą




Procedura calculateAbsolute może być wykorzystana do podziału obiektów na:
- część uczącą i testującą
- poszczególne klasy decyzyjne

Podział na typy obiektów


1. Podział obiektów na część uczącą i testującą
2. Podział obiektu na poszczególne klasy
3. Podział obiektów na poszczególne typy
4. Podział obiektów typy SAFE i BORDER na poszczególne regiony



total
NUM_RARE_PER_GROUP


learnTestAbsRatio = calculateAbsoluteRatio(learnTestRatio, total);
for (int s = 0; s < 2; s++) {
  classAbsRatio[s] = calculateAbsoluteRatio(classRatio, learnTestAbsRatio[s]);
  corrected = false
  do {
  for (int c = 0; c < numClasses; c++) {
    exampleTypeAbsRatio[s, c] = calculateAbsoluteRatio2(exampleTypeRatio[c], classAbsRatio[c]);
    if exampleTypeAbsRatio[s,c].total() == exampleTypeAbsRatio[s, c, RARE])  {
      rest = exampleTypeAbsRatio[s, c, RARE] % NUM_RARE_PER_GROUP;
      if (rest > 0) {
        corrected = true;
        if (rest >= NUM_RARE_PER_GROUP / 2)
          classAbsRatio[s, c] += NUM_RARE_CASE_PER_GROUP - rest;
        else
          classAbsRatio[s, c] -= rest;
      }
    }
  } while(!corrected)
  for (int c = 0 ; c < numClasses; c++) {
    numSafeBorderExamples = exampleTypeAbsRatio[S] + exampleTypeAbsRatio[B];
    regionAbsRatio[s, c] = calculateAbsoluteRatio(regionRatio[c], numSafeBorderExamples)
    for (int r = 0; r < numRegions[c]; r++)
      exampleTypeInRegionAbsRatio[s, c, r] = calculateAbsoluteRate2(exampleTypeRatio.sub(0, 2), regionAbsRatio[s, c, r])
  }
}


// ogólna metoda
calculateAbsolute(ratio, total)
{
  fractions = ratio.toFractions()
  absolute = [fractions.size()] {0};
  if (fractions.total() != 0) {
    sortedIndexes = fractions.sortIndexes(descending)
    subTotal = 0
    for (i = 0; i < fractions.size(); i++)
      if (i <> sortedIndexes[0]) {
        absolute[i] = round(fractions[i]*total)
        subTotal = subTotal + absolute[i]
    }
    validate(subTotal <= total);
    absolute[sortedIndexes[0]] = total - subTotal
  }
  return ratio(abssolute);
}

// metoda dostosowana do wyznaczania rozkładu typów obiektów
calculateAbsolute2(ratio, total, rareSize)
{
  absolute = calculateAbsolute(ratio, total)
  if (absolute[RARE] > 0 && absolute[RARE] != total) {
    rest = absolute[RARE] % NUM_RARE_PER_GROUP
    if (rest != 0) {
      if (rest >= NUM_RARE_PER_GROUP / 2) {
        missing = NUM_RARE_PER_GROUP - rest;
        sortedIndexes = absolute.sortIndexes(descending);
        while (missing > 0) {
          for (int t = 0; t < sortedIndexes.size(); t++) 
            if (sortedIndexes[t] != RARE && absolute[sortedIndexes[y]] > 0) {
              absolute[sortedIndexes[y]]--;
              absolute[RARE]++;
              missing--;
              if (missing == 0) break;
            }
        }
      } else {
        sortedIndexes = absolute.sortIndexes(ascending);
        while (rest > 0) {
          for (int t = 0; t < sortedIndexes.size(); t++) 
            if (sortedIndexes[t] != RARE && absolute[sortedIndexes[y]] > 0) {
              absolute[sortedIndexes[y]]++;
              absolute[RARE]--;
              remaining--;
              if (remaining == 0) break;
        }
      }
    }    
  }
     
}
